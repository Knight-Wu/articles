* 同步复制和异步复制

* 副本的目的

故障切换; 数据就近读取, 提供读取的并发; 

* 如何复制

基于write ahead log 的多, 实际上是操作日志.

* 如何处理复制延迟, 数据不一致问题. 

> 主从复制

1. 总能读到自己的写入, 读写因果性; 说白了就是该读到的就必须读到. 
2. 单调读, 每次读都能读到上次已经读取到的数据, 可以把每个客户端的读都分到一个副本. 
3. 一致前缀读, 一些有因果相关的写入都分配到同一个副本 .

> 多主复制

实际上貌似目前没有实现真正意义上的对同一份数据进行多主复制, 写入都是要加锁的. 

> 无主复制

* 到底如何能保证读取到最新的值, 或者如何处理数据不一致. 

例如写入了多个节点, 某个节点失效没写入, 那么如何避免读到这个落后节点的数据. 一是可以读所有副本, 并返回最新副本的数据, 用版本号; 
根本原因是你写的时候注重了效率, 等于说需要牺牲读去获取写的性能. 

例如如果写操作在某些副本上成功，而在其他节点上失败(例如，因为某些节点上的磁盘已满),在小于w个副本上写入成功。所以整体判定写入失败, 但整体写入失败并没有在写
入成功的副本上回滚。这意味着如果一个写入虽然报告失败，后续的读取仍然可能会读取这次失败写入的值.


引申为 w(写次数) 和 r(读次数) 与  R(副本数) 的关系. r和w是有效读写所需的最低票数。如果有n个副本, 每个写入必须由w节点确认才能被认为是成功的, 并且我们必
须至少为每个读取查询r个节点。
一个常见的选择是使n为奇数,通常为3或5,并设置 $w = r =(n + 1)/ 2$（向上取整）。但是可以根据需要更改数字。例
如，设置$w = n$和$r = 1$的写入很少且读取次数较多的工作负载可能会受益。这使得读取速
度更快，但具有只有一个失败节点导致所有数据库写入失败的缺点。