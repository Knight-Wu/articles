# 定义
多个读写操作整合成一个操作的封装, 要么成功要么失败, 不需要管容错和并发的一些问题, 简化了业务需要考虑的问题

# 事务的属性

ACID, A atomic, 原子性, C consistent 一致性, I Isolation 隔离性, D durable 持久性

* 原子性

要么成功, 要么失败可以回滚

* 一致性
    
应该由应用程序来定义什么是它所关注的一致性, 例如会计系统中借贷相抵是数据一致性的体现. 
原子性，隔离性和持久性是数据库的属性，而一致性（在ACID意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。

* 隔离性

多个事务同时执行的时候, 最后的结果和串行执行的结果一致.

* 持久性 

事务提交成功的时候, 写入的数据就不会丢失了

# 事务的对象
分为单对象和多对象, 单对象意思是更新单个字段或者单行, 多对象意思是更新多行记录

# 事务隔离级别

* read committed 读已提交

读的时候只能看到已经提交的数据, 可以防止脏读, 写只会覆盖已经写入的数据
如何实现呢? 一般要求是读写不互斥, 读的时候如果有事务在写入, 则看到旧值, 取决于读的时候事务有没有提交, 提交了就看到新值. 

* read uncommited 读未提交

相当于每次读取最新的数据, 未提交的也可以读到(脏读), 后续回滚了又读不到了

* 不可重复读

某个人用自己的两个账户各500 发起转账, 在事务完成前看到转入账户只有500, 事务完成后看到转出账户400, 实际现在转入账户应该是600 了, 就感觉少了一百. 现在再读一次就会发现转入账户变了, 就是两次读取结果不一致.
如何实现呢? 快照隔离, 事务只能看到事务开始时的某个时间点的数据库的快照, 后续的更改是看不到的. 
用MVCC 多版本并发控制实现

* MVCC 如何实现

就是当前事务开始时, 会获取一个新的事务id, 列出还未提交的事务id, 可能小于当前事务id, 因为执行没完, 
那么当前事务id 能见的行就是除了这些未提交的事务id 以及比他自己大的事务id(就是后续事务的更改). 

* MVCC的缺陷

大多数情况下只能用于单对象的锁定, 多个对象的操作和读取还是需要应用程序加锁. 例如会议室预定, 可能造成重复预定的情况, 因为两个预定是两个事务, 你无法看到另一个事务的更改(也就是别人的预定).

* 导致写入偏差的幻读

一个事务中的写入改变另一个事务的搜索查询的结果，被称为幻读, 例如会议室预定, 可能造成重复预定的情况, 因为两个预定是两个事务, 你无法看到另一个事务的更改(也就是别人的预定).
MVCC 解决不了, 需要串行化隔离级别. 

1. 一个 SELECT 查询找出符合条件的行，并检查是否符合一些要求。（例如：至少有两名医
生在值班；不存在对该会议室同一时段的预定；
2. 按照第一个查询的结果，应用代码决定是否继续。（可能会继续操作，也可能中止并报
错）
3. 如果应用决定继续操作，就执行写入（插入、更新或删除），并提交事务。
这个写入的效果改变了步骤2 中的先决条件。换句话说，如果在提交写入后，重复执行一
次步骤1 的SELECT查询，将会得到不同的结果。因为写入改变符合搜索条件的行集（现
在少了一个医生值班，那时候的会议室现在已经被预订了）。

* 索引在MVCC 中如何处理

一种方法是每个写入事务会创建一个索引副本, copy on write 技术, 但是要保证此时获取的索引和数据是一致的.

* 丢失更新

两个事务都是先读取再写入, 但是可能在A 事务写入之前, B 就进行了读取, 那么B 再写入就会覆盖A 的结果.
如何避免呢? CAS, 比较看看有没有改过.

# mysql MVCC 如何实现

* 当前读

读取加锁, 读得当前最新版本

* 快照读

读写不互相阻塞, 但是如果在串行化的隔离级别下回退化为当前读

* 新增字段

  * DB_ROW_ID 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引.
  * DB_TRX_ID 6byte, 最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID
  * DB_ROLL_PTR 7byte, 回滚指针，指向这条记录的上一个版本（存储于rollback segment里）.
  * DELETED_BIT 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了

* undo log 

用作事务回滚的. 相比redo log, 只记录着改变部分, 不能从零开始恢复数据.  
insert undo log 记录主键, 删除时直接根据主键去删
</br>
update undo log 记录旧值, 应该只记录修改部分
delete undo log 记录整条记录. 

* 如何判断在当前事务中某行当前的数据是否可见呢

实际上就是判断当前行的事务id 是否提交了吗, 判断的时候会生成一个read view 类似数据库的快照, 里面有三个属性: 一是未提交事务的id 列表, 二是这个列表的最小事务id, 三是生成read view 时未分配的事务id(就是生成快照时的最大事务id 加一) 如果小于最小事务id 则证明已经提交了, 如果大于未分配的事务id 则没提交, 就去未提交的事务id 列表中找, 找到了则不可见, 那么需要从回滚指针链表中找到可见的数据. 到底如何找到哪个数据才是可见的呢?
就依次遍历undo log 链表直到找到满足可见条件的的trxId  


* Repeated read 和 read committed 在MVCC 快照读下为啥不同呢

RC 为何能看到已经提交的事务呢, 就是每次读的时候都会生成一个新的read view, RR 就是事务开始时生成一个 rv, 以后事务中每次读的时候都用这个. 

* redolog

用作数据恢复的