# 定义
多个读写操作整合成一个操作的封装, 要么成功要么失败, 不需要管容错和并发的一些问题, 简化了业务需要考虑的问题

# 事务的属性

ACID, A atomic, 原子性, C consistent 一致性, I Isolation 隔离性, D durable 持久性

* 原子性

要么成功, 要么失败可以回滚

* 一致性
    
应该由应用程序来定义什么是它所关注的一致性, 例如会计系统中借贷相抵是数据一致性的体现. 
原子性，隔离性和持久性是数据库的属性，而一致性（在ACID意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。

* 隔离性

多个事务同时执行的时候, 最后的结果和串行执行的结果一致.

* 持久性 

事务提交成功的时候, 写入的数据就不会丢失了

# 事务的对象
分为单对象和多对象, 单对象意思是更新单个字段或者单行, 多对象意思是更新多行记录

# 事务隔离级别

* read committed 读已提交

读的时候只能看到已经提交的数据, 可以防止脏读, 写只会覆盖已经写入的数据
如何实现呢? 一般要求是读写不互斥, 读的时候如果有事务在写入, 则看到旧值, 取决于读的时候事务有没有提交, 提交了就看到新值. 

* read uncommited 读未提交

相当于每次读取最新的数据, 未提交的也可以读到(脏读), 后续回滚了又读不到了

* 不可重复读

某个人用自己的两个账户各500 发起转账, 在事务完成前看到转入账户只有500, 事务完成后看到转出账户400, 实际现在转入账户应该是600 了, 就感觉少了一百. 现在再读一次就会发现转入账户变了, 就是两次读取结果不一致.
如何实现呢? 快照隔离, 事务只能看到事务开始时的某个时间点的数据库的快照, 后续的更改是看不到的. 
用MVCC 多版本并发控制实现

* MVCC 如何实现

就是当前事务开始时, 会获取一个新的事务id, 列出还未提交的事务id, 可能小于当前事务id, 因为执行没完, 
那么当前事务id 能见的行就是除了这些未提交的事务id 以及比他自己大的事务id(就是后续事务的更改). 

* MVCC的缺陷

大多数情况下只能用于单对象的锁定, 多个对象的操作和读取还是需要应用程序加锁. 例如会议室预定, 可能造成重复预定的情况, 因为两个预定是两个事务, 你无法看到另一个事务的更改(也就是别人的预定).

* 导致写入偏差的幻读

一个事务中的写入改变另一个事务的搜索查询的结果，被称为幻读, 例如会议室预定, 可能造成重复预定的情况, 因为两个预定是两个事务, 你无法看到另一个事务的更改(也就是别人的预定).
MVCC 解决不了, 需要串行化隔离级别. 

1. 一个 SELECT 查询找出符合条件的行，并检查是否符合一些要求。（例如：至少有两名医
生在值班；不存在对该会议室同一时段的预定；
2. 按照第一个查询的结果，应用代码决定是否继续。（可能会继续操作，也可能中止并报
错）
3. 如果应用决定继续操作，就执行写入（插入、更新或删除），并提交事务。
这个写入的效果改变了步骤2 中的先决条件。换句话说，如果在提交写入后，重复执行一
次步骤1 的SELECT查询，将会得到不同的结果。因为写入改变符合搜索条件的行集（现
在少了一个医生值班，那时候的会议室现在已经被预订了）。

* 索引在MVCC 中如何处理

一种方法是每个写入事务会创建一个索引副本, copy on write 技术, 但是要保证此时获取的索引和数据是一致的.

* 丢失更新

两个事务都是先读取再写入, 但是可能在A 事务写入之前, B 就进行了读取, 那么B 再写入就会覆盖A 的结果.
如何避免呢? CAS, 比较看看有没有改过.