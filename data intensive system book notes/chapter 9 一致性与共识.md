# 线性化
定义: 表现起来像是所有数据只有一个副本, 且所有的操作都是原子的.

约束一: 一旦某个读返回了新值, 后续的所有读不管是不是这个这个客户端, 都必须返回新值

# 线性化的权衡

例如cpu 的多级缓存和主存, 多级缓存数据不一致, 就是为了性能, 不用每次都去主存拿数据. 

# tips

> 多主复制无法确定顺序

> 序列号不一定能正确的反映因果或时间关系, 序列号小的不一定是发生在前. 

> 如何保证一定查询到副本的最新值，可以强制调用所有副本的同步操作

* Lamport 时间戳

可以用来解决如何判断因果顺序. 
每个时间戳由节点id 和计数器值构成, 每次请求都会携带此时间戳, 客户端请求前先向节点 A获取最新时间戳, 并在请求中附带, 然后向节点B 请求时, 如果B 的计数器值小于携带值, 则将B 的计数器值置为携带值加一; 如果计数器值相同则根据节点id 来判断先后

* 如何逐步分析一致性问题

一开始是线性一致, 但是很慢, 性能差, 后续是因果一致性, 是较弱的线性一致性, 因果一致性可以用lambort 时间戳实现, 性能好很多, 但是无法解决并发竞争同一个数据的问题, 例如同时抢占一个事先未注册的用户名, 
最后得出共识需要所有节点一致同意的做决定, 且决定做出就不可撤销, 进而发现这下面一些问题都可以等价于共识问题, 一个问题有答案其他问题答案也能推导出, 例如: 