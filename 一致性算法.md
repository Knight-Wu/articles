* 文章
https://m.aliyun.com/yunqi/articles/690624?spm=a2c4e.11155435.0.0.3fe07a1a265rNi

#### paxos 的提出
由以下步骤衍生而成. 
1. 一个acceptor 接受proposer (单点失败)
2. 每个 acceptor 只接受一次proposer , 可能有相同数量的acceptor 接受了两个不同的proposer , 例如偶数个数的acceptor, 或者奇数个数的acceptor 挂了一个.
3. 每个acceptor  接受多次proposer, 则被多数acceptor 接受的proposer 则被accept, 

#### paxos 过程
分为proposer，acceptor， learner 暂时不用管它

* prepare 阶段
proposer  发出一个message , 只包含一个独特的编号为 n, 若acceptor 接受过的message 的编号称为m, 若m 小于n , 则将编号m和 value Mv( 统称为promise) 返回给proposer, 并承诺不会再响应小于n 的message ; 若m >= n , 则回复一个 Nack 给proposer, 让他停止.

* accept 阶段
若 proposer 在上一个阶段收到半数以上的回复, 则可以提出一个propose, 但是这个propose 不是任意的, 若之前acceptor 返回的Mv 均为null ,则可以提出该proposer 原本想提出的value, 否则用收到的promise 中具有最大的编号的vaule 作为提出的 value(为了达成一致 ), 接下来 accptor 会收到 accept 请求, 包含n 和v , 当且仅当 之前accpetor 承诺不再响应小于n 的message, 那么会接受此propose, 并发送accepted 信息给proposer 和learner, 假设此时有其他大于n 的message 收到, 则会拒绝 accept

#### 疑问
* Even with just two proposed values, if each is accepted by
about half the acceptors, failure of a single acceptor could make it impossible to learn which of the values was chosen (如何避免)

> Written with [StackEdit](https://stackedit.io/).
<!--stackedit_data:
eyJoaXN0b3J5IjpbOTIxMDYxODIsMzA5MjEwNzYsLTExMzg3OD
QzNjgsMzMyOTc5MDcsMTgwMTQ5MTQxNyw2MTkwMzU1MjgsMTc3
NzUyMTMzNywyMTI2NDI4MDI1LC0yMDY1MTEwNDg2LC0xMTAxOD
kwMDA3LDczNzc0ODQ3MCw1NjQyMzgxNyw0ODM1Mjg2MDYsLTE2
OTI1NDc4NjEsLTEyNjU4MTc4NDcsMjUyNDkxNDY4LC02NzE1Mj
g1MSwyNjA5NDE3NywtMTg4MzU3MzU1OSwtMjExNjEyMTQzN119

-->